import sys
import os
from sympy import *
from basis_functions import *
from generate_source import *
from generate_project_source import *
from quadrilateral import *
from hexahedron import *
from triangle import *
from prism import *
from tetrahedron import *
from pyramid import *
from multiprocessing import Pool


def header_name_evaluate(t):
    return f"evaluate_{t.namespace.lower()}.hpp"


def header_name_project(t):
    return f"project_{t.namespace.lower()}.hpp"


def source_name_evaluate(t, p):
    return f"evaluate_{t.namespace.lower()}_{p}.cpp"


def source_name_project(t, p):
    return f"project_{t.namespace.lower()}_{p}.cpp"


utility_sycl = "<nektar_interface/utility_sycl.hpp>"
P = 8


def ewrapper(ttx):
    return generate_vector_wrappers(P, ttx, headers=(utility_sycl,))


def pwrapper(ttx):
    return generate_project_wrappers(P, ttx, headers=(utility_sycl,))


if __name__ == "__main__":

    dir_include = os.path.join(sys.argv[1], "include")
    dir_include_gen_dir = os.path.join(
        dir_include, "nektar_interface", "expansion_looping", "generated"
    )
    dir_src = os.path.join(sys.argv[1], "src")
    dir_src_gen_dir = os.path.join(
        dir_src, "nektar_interface", "expansion_looping", "generated"
    )
    dir_include_cmake_dir = os.path.join(
        "${INC_DIR}", "nektar_interface", "expansion_looping", "generated"
    )

    if not os.path.exists(dir_include_gen_dir):
        os.makedirs(dir_include_gen_dir)
    if not os.path.exists(dir_src_gen_dir):
        os.makedirs(dir_src_gen_dir)

    types_evaluate = (
        QuadrilateralEvaluate,
        TriangleEvaluate,
        HexahedronEvaluate,
        PrismEvaluate,
        TetrahedronEvaluate,
        PyramidEvaluate,
    )

    types_project = (
        QuadrilateralProject,
        TriangleProject,
        HexahedronProject,
        PrismProject,
        TetrahedronProject,
        PyramidProject,
    )

    header_list = []
    cmake_include_list = []

    pool = Pool()

    srcs = pool.map(ewrapper, types_evaluate)

    for ti, tx in enumerate(types_evaluate):
        filename = header_name_evaluate(tx)
        header_list.append(f'#include "{filename}"')
        cmake_include_list.append(os.path.join(dir_include_cmake_dir, filename))
        # src = generate_vector_wrappers(P, tx, headers=(utility_sycl,))
        src = srcs[ti]
        with open(os.path.join(dir_include_gen_dir, filename), "w+") as fh:
            fh.write(src)

    srcs = pool.map(pwrapper, types_project)

    for ti, tx in enumerate(types_project):
        filename = header_name_project(tx)
        header_list.append(f'#include "{filename}"')
        cmake_include_list.append(os.path.join(dir_include_cmake_dir, filename))
        # src = generate_project_wrappers(P, tx, headers=(utility_sycl,))
        src = srcs[ti]
        with open(os.path.join(dir_include_gen_dir, filename), "w+") as fh:
            fh.write(src)

    header_list = "\n".join(header_list)
    wrapper_header = f"""
#ifndef _NESO_GENERATED_BASIS_EVALUATION_H__
#define _NESO_GENERATED_BASIS_EVALUATION_H__

#include <neso_particles.hpp>
using namespace NESO::Particles;
#include <CL/sycl.hpp>

#include <nektar_interface/expansion_looping/expansion_looping.hpp>

{header_list}

#endif
"""

    wrapper_filename = os.path.join(dir_include_gen_dir, "generated_evaluate.hpp")
    with open(wrapper_filename, "w+") as fh:
        fh.write(wrapper_header)

    # create the source files
    src_files = []
    for tx in types_evaluate:
        sources = generate_vector_sources(P, tx)
        for px, sx in sources:
            filename = source_name_evaluate(tx, px)
            filepath = os.path.join(dir_src_gen_dir, filename)
            src_files.append(f"${{SRC_DIR}}/{os.path.relpath(filepath, dir_src)}")

            with open(filepath, "w+") as fh:
                fh.write(f"#include <{os.path.relpath(wrapper_filename, dir_include)}>")
                fh.write(sx)

    for tx in types_project:
        sources = generate_project_sources(P, tx)
        for px, sx in sources:
            filename = source_name_project(tx, px)
            filepath = os.path.join(dir_src_gen_dir, filename)
            src_files.append(f"${{SRC_DIR}}/{os.path.relpath(filepath, dir_src)}")

            with open(filepath, "w+") as fh:
                fh.write(f"#include <{os.path.relpath(wrapper_filename, dir_include)}>")
                fh.write(sx)

    cmake_src_list = "\n".join(src_files)

    dir_cmake = os.path.join(sys.argv[1], "cmake")
    if not os.path.exists(dir_cmake):
        os.makedirs(dir_cmake)
    dir_cmake_filename = os.path.join(dir_cmake, "GeneratedEvaluate.cmake")

    cmake_include_list = "\n".join(["    " + cx for cx in cmake_include_list])

    cmake_source = f"""# This is a generated file do not edit this file.
# Instead modify the Python code which generates this file.
# This function adds the generated files to evaluate fields at points.

function(ADD_GENERATED_EVALUATION_INCLUDES)

  list(APPEND HEADER_FILES 
    ${{INC_DIR}}/{os.path.relpath(wrapper_filename, dir_include)}
{cmake_include_list}
  )
  set (HEADER_FILES ${{HEADER_FILES}} PARENT_SCOPE)

endfunction()

function(ADD_GENERATED_EVALUATION_SOURCES)

  list(APPEND LIB_SRC_FILES 
{cmake_src_list}
  )
  set (LIB_SRC_FILES ${{LIB_SRC_FILES}} PARENT_SCOPE)

endfunction()
"""

    with open(dir_cmake_filename, "w+") as fh:
        fh.write(cmake_source)
